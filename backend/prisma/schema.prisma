generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  // url      = env("POSTGRES_URI")
}

model User {
  id String @id @default(uuid())

  name     String
  email    String  @unique
  password String?

  bio          String?
  websites     String[]
  hobby        String?
  avatar       String?
  cover        String?
  gender       EGender?
  city         String?
  birthdayDate DateTime?

  provider EProviders @default(CREDENTIALS)

  likes            Like[]
  favorites        Favorite[]
  followers        Follower[]        @relation("follower")
  followings       Follower[]        @relation("following")
  posts            Post[]
  hashtags         Hashtag[]
  comments         Comment[]
  groups           Group[]
  payments         Payment[]
  followingGroups  GroupFollower[]
  userSubscription UserSubscription?
  stories          Story[]
  chatsAsUserOne   Chat[]            @relation("ChatUserOne")
  chatsAsUserTwo   Chat[]            @relation("ChatUserTwo")
  messages         Message[]

  createdAt DateTime @default(now())
}

model Follower {
  id String @id @default(uuid())

  follower   User   @relation(fields: [followerId], references: [id], name: "following", onDelete: Cascade)
  followerId String

  followingTo   User   @relation(fields: [followingToId], references: [id], name: "follower", onDelete: Cascade)
  followingToId String
}

model Group {
  id String @id @default(uuid())

  name        String
  avatar      String?
  cover       String?
  // Развлекательное, образовательное и тд
  type        String
  description String?
  phone       String?
  email       String?
  website     String?
  address     String?

  admins    User[]
  followers GroupFollower[]
  posts     Post[]

  createdAt DateTime @default(now())
}

model GroupFollower {
  id String @id @default(uuid())

  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId String
}

model Post {
  id String @id @default(uuid())

  text   String
  images String[]
  video  String?

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  comments  Comment[]
  likes     Like[]
  favorites Favorite[]
  hashtags  Hashtag[]

  createdAt DateTime  @default(now())
  updatedAt DateTime?
  group     Group?    @relation(fields: [groupId], references: [id])
  groupId   String?
}

model Comment {
  id String @id @default(uuid())

  text  String
  image String?

  likes Like[]

  replyTo   Comment? @relation(fields: [replyToId], references: [id], name: "replies")
  replyToId String?

  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  createdAt DateTime  @default(now())
  updatedAt DateTime?

  replies Comment[] @relation("replies")
}

model Like {
  id String @id @default(uuid())

  type    ELikeType
  likedId String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  Post      Post?    @relation(fields: [postId], references: [id])
  postId    String?
  Comment   Comment? @relation(fields: [commentId], references: [id])
  commentId String?

  createdAt DateTime @default(now())
}

model Favorite {
  id String @id @default(uuid())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  post   Post   @relation(fields: [postId], references: [id])
  postId String
}

model Hashtag {
  id String @id @default(uuid())

  name String @unique

  posts Post[]
  users User[]
}

model Subscription {
  id String @id @default(uuid())

  title       String
  description String
  price       Int

  userSubscriptions UserSubscription[]
  payments          Payment[]
}

model UserSubscription {
  id String @id @default(uuid())

  status ESubscriptionStatuses @default(DISABLED)

  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  paymentId String

  user   User   @relation(fields: [userId], references: [id])
  userId String @unique

  expiresAt DateTime
}

model Payment {
  id String @id @default(uuid())

  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  paymentMethodId   String?
  yookassaPaymentId String

  status EPaymentStatuses @default(PENDING)

  user   User   @relation(fields: [userId], references: [id])
  userId String

  createdAt DateTime @default(now())
}

model Story {
  id String @id @default(uuid())

  image String
  text  String?

  user   User   @relation(fields: [userId], references: [id])
  userId String

  createdAt DateTime @default(now())
}

model Chat {
  id String @id @default(uuid())

  lastMessage String?

  userOne   User      @relation("ChatUserOne", fields: [userOneId], references: [id], map: "chat_user_one")
  userOneId String
  userTwo   User      @relation("ChatUserTwo", fields: [userTwoId], references: [id])
  userTwoId String
  messages  Message[]

  createdAt DateTime @default(now())
}

model Message {
  id String @id @default(uuid())

  text  String
  image String?

  user   User   @relation(fields: [userId], references: [id])
  userId String

  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)
  chatId String

  createdAt DateTime  @default(now())
  updatedAt DateTime?
}

enum ELikeType {
  POST
  COMMENT
  HASHTAG
}

enum EProviders {
  CREDENTIALS
  YANDEX
  GOOGLE
}

enum EGender {
  MALE
  FEMALE
}

enum ESubscriptionStatuses {
  ACTIVE
  DISABLED
}

enum EPaymentStatuses {
  PENDING
  SUCCEEDED
  FAILED
}
