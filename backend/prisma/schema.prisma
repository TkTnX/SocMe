generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URI")
}

model User {
  id String @id @default(uuid())

  name     String
  email    String  @unique
  password String?

  bio          String?
  websites     String[]
  hobby        String?
  avatar       String?
  cover        String?
  gender       EGender?
  city         String?
  birthdayDate DateTime?

  provider EProviders @default(CREDENTIALS)

  likes             Like[]
  favorites         Favorite[]
  followers         Follower[]        @relation("follower")
  followings        Follower[]        @relation("following")
  posts             Post[]
  hashtags          Hashtag[]
  comments          Comment[]
  groups            Group[]
  payments          Payment[]
  followingGroups   GroupFollower[]
  userSubscription UserSubscription?

  createdAt DateTime @default(now())
}

model Follower {
  id String @id @default(uuid())

  follower   User   @relation(fields: [followerId], references: [id], name: "following", onDelete: Cascade)
  followerId String

  followingTo   User   @relation(fields: [followingToId], references: [id], name: "follower", onDelete: Cascade)
  followingToId String
}

model Group {
  id String @id @default(uuid())

  name        String
  avatar      String?
  cover       String?
  // Развлекательное, образовательное и тд
  type        String
  description String?
  phone       String?
  email       String?
  website     String?
  address     String?

  admins    User[]
  followers GroupFollower[]
  posts     Post[]

  createdAt DateTime @default(now())
}

model GroupFollower {
  id String @id @default(uuid())

  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  groupId String
}

model Post {
  id String @id @default(uuid())

  text   String
  images String[]

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  comments  Comment[]
  likes     Like[]
  favorites Favorite[]
  hashtags  Hashtag[]

  createdAt DateTime  @default(now())
  updatedAt DateTime?
  group     Group?    @relation(fields: [groupId], references: [id])
  groupId   String?
}

model Comment {
  id String @id @default(uuid())

  text  String
  image String?

  likes Like[]

  replyTo   Comment? @relation(fields: [replyToId], references: [id], name: "replies")
  replyToId String?

  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  createdAt DateTime  @default(now())
  updatedAt DateTime?

  replies Comment[] @relation("replies")
}

model Like {
  id String @id @default(uuid())

  type    ELikeType
  likedId String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  Post      Post?    @relation(fields: [postId], references: [id])
  postId    String?
  Comment   Comment? @relation(fields: [commentId], references: [id])
  commentId String?

  createdAt DateTime @default(now())
}

model Favorite {
  id String @id @default(uuid())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  post   Post   @relation(fields: [postId], references: [id])
  postId String
}

model Hashtag {
  id String @id @default(uuid())

  name String @unique

  posts Post[]
  users User[]
}

model Subscription {
  id String @id @default(uuid())

  title       String
  description String
  price       Int

  userSubscriptions UserSubscription[]
  payments         Payment[]
}

model UserSubscription {
  id String @id @default(uuid())

  status ESubscriptionStatuses @default(PENDING)

  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String       @unique

  paymentId String

  user   User   @relation(fields: [userId], references: [id])
  userId String @unique

  expiresAt DateTime
}

model Payment {
  id String @id @default(uuid())

  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  user   User   @relation(fields: [userId], references: [id])
  userId String

  createdAt DateTime @default(now())
}

enum ELikeType {
  POST
  COMMENT
  HASHTAG
}

enum EProviders {
  CREDENTIALS
  YANDEX
  GOOGLE
}

enum EGender {
  MALE
  FEMALE
}

enum ESubscriptionStatuses {
  PENDING
  SUCCEEDED
  FAILED
}
